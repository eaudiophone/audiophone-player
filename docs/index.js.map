{
  "version": 3,
  "sources": ["../src/index.js"],
  "sourcesContent": ["// registro de SW.\nif (navigator.serviceWorker) navigator.serviceWorker.register('./sw.js');\n\n/**\n * @typedef Track\n * @type {Object}\n * @property {string} name\n * @property {number} index\n * @property {string} filePath \n * @property {boolean} selected\n * @property {string} format\n */\n\n/**\n * @typedef State\n * @type {Object}\n * @property {Track[]} playlist\n * @property {Track | null} selectedTrack\n * @property {(playlist: Track[]) => void} setPlaylist\n * @property {(track: Track) => void} setSelectedTrack\n * @property {Howl | null} audio  instancia de Howl.js\n * @property {(data: {format: string, filePath: string}) => void} setAudio\n */\n\nconst isMobile = (window.matchMedia('screen and (max-width: 768px)')).matches; \nconst SCREEN = isMobile ? '#mobile' : '#desktop';\nconst UI = {\n    uploadButton: document.querySelector(SCREEN + ' ' + 'button#load-playlist'),\n    inputFile: document.querySelector(SCREEN + ' ' + '#upload-input'),\n    playListData: document.querySelector(SCREEN + ' ' + '#playlist #data'),\n    inputSearch: document.querySelector(SCREEN + ' ' + '#search'),\n    player: document.querySelector(SCREEN + ' ' + 'footer#player'),\n    volume: document.querySelector(SCREEN + ' ' + 'footer #indicator-volume'), \n    buttonPlay: document.querySelector(SCREEN + ' ' + '#play-pause'),   \n    durationTrack: document.querySelector(SCREEN + ' ' + 'span#duration'),\n    timerTrack: document.querySelector(SCREEN + ' ' + 'span#timer'),\n    progress: document.querySelector(SCREEN + ' ' + '#progress'),\n    nextTrack: document.querySelector(SCREEN + ' ' + '#next'),\n    prevTrack: document.querySelector(SCREEN + ' ' + '#prev'),\n    titleTrack: document.querySelector(SCREEN + ' ' +'#title-track'),\n};\n\n/** inicializa el estado de la aplicacion */    \nfunction initState(set) {\n    \n    /** @type {State} */\n    const STATE = {\n        playlist: [],\n        selectedTrack: null,\n        audio: null,\n        setPlaylist: playlist => set(state => ({...state, playlist})),\n        setSelectedTrack: track => set(state => ({...state, selectedTrack: track})), \n        setAudio: ({filePath, format}) => set(state => {\n            if (state.audio) state.audio.unload(); // desmonta el sonido si existe una instancia\n            \n            // crea una referencia local que apunta al mismo objeto de sonido\n            // dentro de la configuraci\u00F3n\n            let sound = state.audio = new Howl({\n                src: [filePath],\n                html5: true, // html5 streaming, ideal para grandes buffers de datos\n                format: [format], // formato del archivo (requerido en Web PWA)\n                onload: () => {\n                    if (UI.buttonPlay.getAttribute('value') === 'play') UI.buttonPlay.click();\n                },\n                onloaderror: (id, error) => {\n                    console.error('Error al cargar el audio', filePath, error);\n                },\n                onplay: () => {\n                    if (!UI.durationTrack) return;\n                    \n                    let duration = sound.duration();\n                    UI.durationTrack.innerHTML = formatTime(Math.round(duration));\n\n                    requestAnimationFrame(updateTimer);\n                },\n                onend: () => {\n                    if (UI.buttonPlay.getAttribute('value') === 'pause') UI.buttonPlay.click();\n\n                    // pasamos a la siguiente valor de la lista de reproduccion \n                    // si no es el ultima pista\n                    if (state.selectedTrack && state.selectedTrack.index !== (state.playlist.length - 1)) \n                        UI.nextTrack.click();\n                },\n                onseek: () => {\n                    // activa el evento y actualiza el frame cuando haya un salto\n                    requestAnimationFrame(updateTimer);\n                }\n            }); \n\n            return {...state, audio: sound};\n        }),\n    };\n\n    return STATE;\n};\n\n/**\n * carga la pista en el reproductor\n * @param {number} index indice de la pista\n */\nfunction loadTrack(index) {\n    /** @type {State} */\n    const state = STORE.getState();\n    \n    if (state.playlist.length === 0) {\n        console.error('No tracks loaded ...');\n        return;\n    }\n\n    // se genera una playlist nueva\n    const newPlaylist = state.playlist.map(track => {\n        if (track.index === index) return {...track, selected: true};\n        return {...track, selected: false};\n    });\n    \n    // console.log(newPlaylist);\n\n    state.setPlaylist(newPlaylist);\n\n    // procedemos a pasar los datos al componente del reproductor\n    const track = newPlaylist.find(track => track.index === index) || null;\n    \n    state.setSelectedTrack(track);\n}\n\n/**\n * Manejador del boton de carga de archivos\n */\nasync function handleLoadButton() {\n    const playlist = await getFiles();\n\n    if (playlist.length === 0) return;\n\n    /** @type {State} */\n    const state = STORE.getState();\n\n    // establecemos una copia en el session storage\n    window.sessionStorage.setItem('playlist', JSON.stringify(playlist));\n    \n    state.setPlaylist(playlist);\n}\n\n/**\n * busca la pista dentro de la lista de reproduccion\n * @param {InputEvent} event \n */\nfunction searchTrack(event) {\n    /** @type {State} */\n    const state = STORE.getState();\n\n    /** @type {string} */\n    let value = event.target.value;\n    \n    /** @type {Array<Track>} */\n    let playList = [];\n\n    if (value.length === 0) {\n        // obtenemos desde el session storage\n        // luego verificamos si existe una pista seleccionada\n        // y la marcamos para que aparezca seleccionado en pista\n\n        /** @type {Array<Track>} */\n        playList = JSON\n            .parse(window.sessionStorage.getItem('playlist'))\n            .map(track => {\n                if (state.selectedTrack && track.index === state.selectedTrack.index) {\n                    return {...track, selected: true};\n                }\n\n                return track;\n            });\n\n    } else {\n        // validar datos alfanumericos ...\n        value = value.toLowerCase(); // pasamos a lowercase\n        \n        if (!(/^[\\w\\s\\d]{1,255}$/).test(value)) {\n            console.error(new Error('Solo caracteres alfan\u00FAmericos'));\n            return;\n        }\n\n        // filtramos la lista\n        // devuelve las coincidencias\n        playList = state.playlist.filter(track => {\n            const position = (track.name.toLowerCase()).search(value);\n            return (position !== -1); \n        });\n    }\n\n    // actualizamos la nuevo playlist\n    state.setPlaylist(playList);\n}\n\n/** cambia la pista en el reproductor */\nfunction switchTrack() {\n    /** @type {State} */\n    const {audio} = STORE.getState();\n\n    audio.stop();\n\n    // cambiamos los atributos del boton\n    UI.buttonPlay.setAttribute('value', 'pause');\n    UI.buttonPlay.setAttribute('src', 'img/play.svg');\n\n    // reproducimos la nueva pista\n    UI.buttonPlay.click();\n}\n\n/**\n * renderiza el listado de archivos de musica\n * @param {State} state\n * @param {State} prevState \n */\nfunction renderPlaylist(state, prevState) {\n    if (state.playlist === prevState.playlist) return;\n    if (state.playlist.length === 0) return;\n\n    UI.playListData.innerHTML = state.playlist.map(file => {\n        return (`\n            <div class=\"item ${file.selected ? 'selected' : ''}\" track=\"${file.index}\">\n                <img src=\"img/play.svg\" alt=\"play\" class=\"icons\" />\n                <span>${\n                    file.name.length > 35 ? \n                        file.name.slice(0, 35) + '...' : \n                        file.name\n                }</span>\n            </div>    \n        `);\n    }).join('');\n    \n    // a\u00F1adimos los eventos de click\n    const items = Array.from(UI.playListData.querySelectorAll('.item'));\n    items.forEach(item => item.addEventListener(\n        'click', \n        () => loadTrack(Number(item.getAttribute('track')))\n    ));\n}\n\n/**\n * crea la instancia de howler e inicia el reproductor\n * @param {State} state\n * @param {State} prevState \n */\nfunction loadTrackPlayer(state, prevState) {\n    if (state.selectedTrack === prevState.selectedTrack) return;\n    if (!UI.titleTrack) return;\n\n    if (!state.selectedTrack) {\n        UI.titleTrack.innerText = 'No track loaded';            \n        return;\n    }\n    \n    // cambia la pista\n    if (state.audio && state.audio.playing()) switchTrack();\n\n    UI.titleTrack.innerText = state.selectedTrack.name;\n\n    // genera la instancia de Howler.js\n    state.setAudio({\n        filePath: state.selectedTrack.filePath, \n        format: state.selectedTrack.format\n    });\n}\n\n/**\n * manejador de instancias de howler\n * @param {Event} event \n */\nfunction handleVolume(event) {\n    const element = event.target;\n\n    let value = Number(element.value); \n    let maxValue = Number(element.max);\n    let progress = (value / maxValue) * 100;\n    \n    // establecemos los estilos de la linea\n    element.style.background = (`linear-gradient(to right, var(--foreground) ${progress}%, var(--borders) ${progress}%)`);\n    \n    // establece el volumen global de todas las instancias de Howler\n    Howler.volume(value / 100);\n}\n\n/**\n * maneja la reproduccion de la pista de audio\n * @param {Event} event\n */\nfunction handlePlay({target}) {\n    /** @type {State} */\n    const {audio, playlist, selectedTrack} = STORE.getState();\n\n    // validamos si existe alguna pista en la playlist\n    let isNotReady = playlist.length === 0 || !selectedTrack;\n    if (isNotReady) return;\n\n    /** @type {'pause' | 'play'} */\n    const value = target.getAttribute('value');\n    \n    if (value === 'pause') {\n        // cambia la imagen del boton \n        target.setAttribute('value', 'play');\n        target.setAttribute('src', 'img/play.svg');\n\n        if (audio && audio.state() === 'loaded') {\n            audio.pause(); \n        \n        } else if (audio && audio.state() !== 'loading') {\n            console.warn('No se ha cargado ning\u00FAn archivo de audio o a\u00FAn est\u00E1 cargando.');\n        \n        }\n    }\n    \n    if (value === 'play') {\n        target.setAttribute('value', 'pause');\n        target.setAttribute('src', 'img/pause.svg');\n\n        if (audio && audio.state() === 'loaded') {\n            audio.play();\n        \n        } else if (audio && audio.state() !== 'loading') {\n            console.warn('No se ha cargado ning\u00FAn archivo de audio o a\u00FAn est\u00E1 cargando.');\n        \n        }\n    }\n}\n\n\n/**\n * aplica un formato de tiempo de segundos a M:SS\n * @param {number} seconds Segundos a formatear\n * @returns {string} tiempo formateado\n*/\nfunction formatTime(seconds) {\n    let minutes = Math.floor(seconds / 60) || 0;\n    let secs = (seconds - minutes * 60) || 0;\n\n    return (`${minutes}:${secs < 10 ? '0' : ''}${secs}`);\n}\n\n/**\n * funcion que controla la actualizacion del tiempo\n */\nfunction updateTimer() {\n    /** @type {State} */\n    const {audio} = STORE.getState();\n    const seek = audio.seek() || 0;\n\n    if (UI.timerTrack) UI.timerTrack.innerHTML = formatTime(Math.round(seek));\n\n    let width = ((seek / audio.duration()) * 100) || 0;\n\n    if (UI.progress) {\n        // establecemos los estilos de la linea\n        UI.progress.value = width;  \n        UI.progress.style.background = (`linear-gradient(to right, var(--color-indicators) ${width}%, var(--borders) ${width}%)`);\n    } \n\n    // ejecuta la animacion mientras se reproduce la pista\n    if (audio.playing()) requestAnimationFrame(updateTimer);\n}\n\n/**\n * salta a la pista siguiente\n * @param {'next' | 'prev'} direction \n */\nfunction skipTo(direction = 'next') {\n    /** @type {State} */\n    const {playlist, selectedTrack, audio, setSelectedTrack, setPlaylist} = STORE.getState();\n    \n    if (playlist.length === 0) return;\n\n    let index = selectedTrack.index || 0;\n\n    if (direction === 'prev') {\n        index = selectedTrack.index - 1;\n        \n        // nos ubica al ultimo de la lista\n        if (index < 0) index = playlist.length - 1;\n    }\n\n    if (direction === 'next') {\n        index = selectedTrack.index + 1;\n        \n        // si alcanza el limite retrocede al primer elemento\n        if (index >= playlist.length) index = 0;\n    }\n\n    // detiene la pista actual\n    audio.stop();\n    if (UI.buttonPlay.getAttribute('value') === 'pause') UI.buttonPlay.click();\n\n    // reset progress\n    // establecemos los estilos de la linea\n    UI.progress.value = 0;\n    UI.progress.style.background = (`var(--borders)`);\n\n    // actualiza la lista con la nueva posicion seleccionada\n    // para se\u00F1alar el nuevo elemento\n    const newPlaylist = playlist.map(track => {\n        if (track.index === index) {\n            return {...track, selected: true};\n        }\n        \n        return {...track, selected: false};\n    });\n\n    setPlaylist(newPlaylist);\n\n    setSelectedTrack(playlist[index]);\n}\n\n/**\n * salta a cualquier seccion de la pista\n * @param {MouseEvent} event \n */\nfunction jumpTo(event) {\n    /** @type {State} */\n    const {playlist, selectedTrack, audio} = STORE.getState();\n    \n    if (playlist.length === 0 || !selectedTrack) return;\n    \n    // permite obtener el porcentaje de la posicion donde se hace \n    // click al indicador\n    let clientX = 0;\n\n    // verificamos si dispositivo movile\n    if (isMobile) {\n        clientX = event.touches[0].clientX;\n    \n    } else {\n        clientX = event.clientX;\n    \n    }\n\n    let per = clientX / window.innerWidth;\n\n    // aplicamos el salto y luego la animacion\n    if (audio.playing()) audio.seek(audio.duration() * per);\n}\n\n/** obtiene la instancias de los archivos \n * @returns {Promise<Track[]>}\n*/\nasync function getFiles() {\n    return new Promise(resolve => {\n        UI.inputFile.addEventListener('input', event => {\n            const {files} = event.target;\n            \n            /** @type {Track[]} */\n            let tracks = [];\n        \n            for (const file of files) {\n                tracks = [\n                    ...tracks, \n                    {\n                        selected: false, \n                        index: tracks.length, \n                        name: file.name || '', \n                        filePath: URL.createObjectURL(file),\n                        // manda el formato a howler ya que el filePath\n                        // para que reproduzca el archivo\n                        format: file.type.split('/')[1] \n                    }\n                ];\n            }\n            \n            resolve(tracks);\n    \n        }, {once: true}); // el evento se ejecuta solo una vez\n        \n        // llamamos al input file cuando registre el cambio dispara el evento\n        UI.inputFile.click();\n    });\n};\n\n// main ...\nif (!UI.uploadButton) return;\n\nUI.uploadButton.addEventListener('click', handleLoadButton);   \n\nif (!UI.inputSearch) return;\n\nUI.inputSearch.addEventListener('input', searchTrack);\n\nif (!UI.volume) return;\n\nUI.volume.addEventListener('input', handleVolume);\n\nif (!UI.buttonPlay) return;\n\nUI.buttonPlay.addEventListener('click', handlePlay);\n\nif (!UI.prevTrack) return;\n\nUI.prevTrack.addEventListener('click', () => skipTo('prev'));\n\nif (!UI.nextTrack) return;\n\nUI.nextTrack.addEventListener('click', () => skipTo('next'));\n\nif (!UI.progress) return;\n\nif (!isMobile) {\n    // event click para escritorio\n    UI.progress.addEventListener('click', jumpTo);\n} else {\n    // event click para moviles\n    UI.progress.addEventListener('touchstart', jumpTo);\n}  \n\nconst STORE = zustandVanilla.createStore(initState);\n\n// patron observador Zustand\n// nos subscribimos al cambio del estado\nSTORE.subscribe(renderPlaylist); // renderiza la playlist cuando se cambia la playlist\nSTORE.subscribe(loadTrackPlayer); // carga el track seleccionado"],
  "mappings": "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",
  "names": ["require_index", "__commonJSMin", "isMobile", "SCREEN", "UI", "initState", "set", "playlist", "state", "__spreadProps", "__spreadValues", "track", "filePath", "format", "sound", "id", "error", "duration", "formatTime", "updateTimer", "loadTrack", "index", "STORE", "newPlaylist", "handleLoadButton", "getFiles", "searchTrack", "event", "value", "playList", "switchTrack", "audio", "renderPlaylist", "prevState", "file", "item", "loadTrackPlayer", "handleVolume", "element", "maxValue", "progress", "handlePlay", "target", "selectedTrack", "seconds", "minutes", "secs", "seek", "width", "skipTo", "direction", "setSelectedTrack", "setPlaylist", "jumpTo", "clientX", "per", "resolve", "files", "tracks"]
}
